import { GoogleGenerativeAI } from '@google/generative-ai'; import { supabase } from './supabase'; const genAI = new GoogleGenerativeAI(import.meta.env.VITE_GEMINI_API_KEY || 'AIzaSyB66RXtmuEvvh42ZGPLxk57nZ8JRht14QE'); export interface BookingData { customer_name?: string; customer_email?: string; customer_phone?: string; pickup_location?: string; dropoff_location?: string; booking_date?: string; booking_time?: string; service_type?: string; vehicle_preference?: string; passenger_count?: number; special_requirements?: string; } export interface ChatMessage { role: 'user' | 'assistant'; content: string; timestamp: Date; } export class VIPBookingAssistant { private model; private conversationHistory: ChatMessage[] = []; private extractedData: BookingData = {}; private sessionId: string; private currentStep: string = 'greeting'; private userInterestLevel: 'high' | 'medium' | 'low' | 'disinterested' | 'confused' = 'medium'; private conversationContext: string = ''; private lastQuestionAsked: string = ''; private attemptCount: { [key: string]: number } = {}; private hasGreeted: boolean = false; private offTopicCount: number = 0; private stepOrder = [ 'greeting', 'name', 'email', 'phone', 'service_type', 'pickup_location', 'dropoff_location', 'booking_date', 'booking_time', 'passenger_count', 'vehicle_preference', 'special_requirements', 'confirmation', 'submission' ]; private services = [ { name: 'Chauffeur Service', description: 'Professional chauffeur-driven transport for all occasions', vehicles: ['Executive Sedan', 'Luxury SUV', 'Premium MPV'] }, { name: 'Airport Transfers', description: 'Reliable transfers with flight monitoring and meet & greet', vehicles: ['Executive Sedan', 'Luxury SUV', 'Premium MPV'] }, { name: 'Wedding Transport', description: 'Elegant transport for your special day', vehicles: ['Rolls Royce', 'Bentley', 'Luxury Sedan'] }, { name: 'Corporate Transport', description: 'Executive business travel solutions', vehicles: ['Executive Sedan', 'Luxury SUV', 'Premium MPV'] }, { name: 'Event Transport', description: 'Specialized transport for premieres and galas', vehicles: ['Rolls Royce', 'Bentley', 'Luxury SUV'] }, { name: 'Security Services', description: 'Professional close protection with SIA-licensed operatives', vehicles: ['Armored Vehicle', 'Executive SUV', 'Security Escort'] } ]; constructor(sessionId: string) { this.sessionId = sessionId; this.model = genAI.getGenerativeModel({ model: 'gemini-pro' }); console.log('VIP Booking Assistant initialized with session:', sessionId); // Initialize attempt counts this.stepOrder.forEach(step => { this.attemptCount[step] = 0; }); } private analyzeUserMessage(userMessage: string): { isRelevant: boolean; sentiment: 'positive' | 'negative' | 'neutral' | 'confused'; intent: 'booking' | 'question' | 'smalltalk' | 'complaint' | 'goodbye'; containsData: boolean; } { const message = userMessage.toLowerCase().trim(); // Check for disinterest/goodbye const disinterestKeywords = [ 'no', 'nope', 'nah', 'no thanks', 'not interested', 'don\'t want', 'pass', 'forget it', 'leave it', 'drop it', 'never mind', 'stop', 'not now', 'maybe later', 'another time', 'later', 'not ready', 'not today', 'bye', 'goodbye', 'see you', 'talk later', 'gtg', 'gotta go' ]; // Check for positive responses const positiveKeywords = [ 'yes', 'yeah', 'yep', 'sure', 'okay', 'ok', 'alright', 'definitely', 'absolutely', 'perfect', 'great', 'excellent', 'sounds good', 'let\'s do it' ]; // Check for questions const questionKeywords = [ 'what', 'how', 'when', 'where', 'why', 'which', 'who', 'can you', 'do you', 'will you', 'are you', 'is there', '?' ]; // Check for small talk const smallTalkKeywords = [ 'hello', 'hi', 'hey', 'good morning', 'good afternoon', 'good evening', 'how are you', 'weather', 'nice day', 'thank you', 'thanks' ]; // Check for complaints const complaintKeywords = [ 'expensive', 'too much', 'cheap', 'disappointed', 'problem', 'issue', 'wrong', 'bad', 'terrible', 'awful', 'hate', 'don\'t like' ]; const isRelevant = this.isMessageRelevantToBooking(message); const containsData = this.messageContainsBookingData(message); let sentiment: 'positive' | 'negative' | 'neutral' | 'confused' = 'neutral'; let intent: 'booking' | 'question' | 'smalltalk' | 'complaint' | 'goodbye' = 'booking'; if (disinterestKeywords.some(keyword => message.includes(keyword))) { sentiment = 'negative'; intent = 'goodbye'; } else if (positiveKeywords.some(keyword => message.includes(keyword))) { sentiment = 'positive'; } else if (complaintKeywords.some(keyword => message.includes(keyword))) { sentiment = 'negative'; intent = 'complaint'; } else if (questionKeywords.some(keyword => message.includes(keyword))) { intent = 'question'; } else if (smallTalkKeywords.some(keyword => message.includes(keyword))) { intent = 'smalltalk'; sentiment = 'positive'; } // Detect confusion const confusionIndicators = ['what', 'huh', 'confused', 'don\'t understand', 'what do you mean']; if (confusionIndicators.some(indicator => message.includes(indicator))) { sentiment = 'confused'; } return { isRelevant, sentiment, intent, containsData }; } private isMessageRelevantToBooking(message: string): boolean { const bookingKeywords = [ 'transport', 'car', 'taxi', 'ride', 'book', 'booking', 'chauffeur', 'airport', 'wedding', 'corporate', 'event', 'security', 'pickup', 'dropoff', 'location', 'address', 'time', 'date', 'passenger', 'vehicle', 'service', 'name', 'email', 'phone', 'number' ]; return bookingKeywords.some(keyword => message.includes(keyword)); } private messageContainsBookingData(message: string): boolean { // Check for email patterns const emailPattern = /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/; // Check for phone patterns const phonePattern = /(\+44|0)[\s-]?(\d{4})[\s-]?(\d{3})[\s-]?(\d{3})|(\d{5})[\s-]?(\d{6})/; // Check for date patterns const datePattern = /(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})|today|tomorrow|next week/i; // Check for time patterns const timePattern = /\d{1,2}[:\.]?\d{0,2}\s?(am|pm|AM|PM)?/; // Check for numbers (passenger count, etc.) const numberPattern = /\b\d+\b/; return emailPattern.test(message) || phonePattern.test(message) || datePattern.test(message) || timePattern.test(message) || (numberPattern.test(message) && message.length > 2); } private handleOffTopicMessage(userMessage: string, analysis: any): string { this.offTopicCount++; const responses = { smalltalk: [ "That's lovely! I appreciate the chat. Now, to help you with your VIP transport needs", "Thank you for sharing! I'm here to make your luxury travel arrangements seamless. Let's continue with", "That's nice to hear! As your VIP transport specialist, I'd love to help you arrange your journey. Let me ask about" ], question: [ "Great question! I'd be happy to help with that after we get your booking sorted. For now, let me ask about", "I understand you'd like to know more. I'll address that shortly. First, let's continue with getting", "That's something I can definitely help clarify! To give you the best answer, let me first ask about" ], complaint: [ "I understand your concerns, and I'm here to ensure you have the best possible experience. Let's work through this together. To start,", "Thank you for sharing that feedback. I want to make sure we exceed your expectations this time. May I ask about", "I appreciate you bringing that up. Let's make sure everything is perfect for your booking. Could you help me with" ], confused: [ "No worries at all! Let me explain this more clearly. I'm here to help you book luxury VIP transport.", "I understand this might seem like a lot. Let's take it step by step. I'm simply helping you arrange premium transport.", "That's perfectly fine! I'm Alex, your VIP transport assistant, and I'm here to make booking a luxury car service super easy for you." ] }; let responseCategory = 'smalltalk'; if (analysis.intent === 'question') responseCategory = 'question'; else if (analysis.intent === 'complaint') responseCategory = 'complaint'; else if (analysis.sentiment === 'confused') responseCategory = 'confused'; const responseOptions = responses[responseCategory]; const randomResponse = responseOptions[Math.floor(Math.random() * responseOptions.length)]; // If they're repeatedly off-topic, be more direct if (this.offTopicCount > 2) { return ${randomResponse} your ${this.getCurrentStepQuestion()}. I want to make sure I arrange the perfect transport for you!; } return ${randomResponse} ${this.getCurrentStepQuestion()}.; } private getCurrentStepQuestion(): string { const questions = { name: "your name", email: "your email address", phone: "your phone number", service_type: "which transport service you need", pickup_location: "where you'd like to be picked up", dropoff_location: "where you're heading to", booking_date: "what date you need the transport", booking_time: "what time works best for you", passenger_count: "how many passengers will be traveling", vehicle_preference: "which type of vehicle you'd prefer", special_requirements: "if you have any special requirements" }; return questions[this.currentStep] || "the next detail for your booking"; } private getIntelligentResponse(userMessage: string): string { const analysis = this.analyzeUserMessage(userMessage); // Handle goodbye/disinterest if (analysis.intent === 'goodbye' && analysis.sentiment === 'negative') { this.userInterestLevel = 'disinterested'; return "I completely understand! No pressure at all. If you ever need VIP transport services in the future, I'll be here to help. Have a wonderful day! ðŸ˜Š"; } // Handle off-topic but maintain context if (!analysis.isRelevant && !analysis.containsData) { return this.handleOffTopicMessage(userMessage, analysis); } // Continue with normal flow return this.getStepResponse(this.currentStep, userMessage, analysis); } private getStepResponse(step: string, userMessage: string, analysis: any): string { this.attemptCount[step] = (this.attemptCount[step] || 0) + 1; const responses = { greeting: () => { if (!this.hasGreeted) { this.hasGreeted = true; return "Hello! I'm Alex, your VIP transport specialist. I'm here to arrange luxury transport that exceeds your expectations.\n\nWhether you need airport transfers, wedding transport, corporate travel, or our exclusive security services - I'll make it seamless for you.\n\nWhat's your name? I'd love to provide you with personalized service."; } return "Great to meet you! What's your name so I can assist you personally?"; }, name: () => { if (this.extractedData.customer_name) { const firstName = this.extractedData.customer_name.split(' ')[0]; const greetings = [ Lovely to meet you, ${firstName}! I'm excited to help arrange your perfect journey., Wonderful, ${firstName}! I'm here to make your transport booking effortless., Perfect, ${firstName}! Let's get your luxury transport sorted. ]; return greetings[Math.floor(Math.random() * greetings.length)]; } if (this.attemptCount[step] > 2) { return "I understand you might prefer to keep things private. You can just give me a first name or even a preferred name - whatever you're comfortable with!"; } return analysis.sentiment === 'confused' ? "No worries! I just need something to call you - it could be your first name, a nickname, or whatever you prefer!" : "I'd love to know what to call you! What's your name?"; }, email: () => { if (this.extractedData.customer_email) { return "Perfect! That email address looks good. I'll use this to send you booking confirmations and updates."; } if (this.attemptCount[step] > 2) { return "I understand email privacy is important. I just need this to send you booking confirmations and coordinate with our team. Your email stays completely secure with us!"; } const firstName = this.extractedData.customer_name?.split(' ')[0] || ''; return analysis.sentiment === 'confused' ? ${firstName}, I need your email address so I can send you confirmation details about your booking. Just your regular email will do! : Thanks ${firstName}! Could you share your email address? This way I can send you all the booking confirmations and journey details.; }, phone: () => { if (this.extractedData.customer_phone) { return "Excellent! I've got your phone number. This helps us provide real-time updates about your chauffeur's arrival."; } if (this.attemptCount[step] > 2) { return "Your phone number helps us coordinate perfectly - like letting you know when your chauffeur arrives! UK or international numbers both work fine."; } return "Perfect! Now, could you share your phone number? This way our team can coordinate your journey perfectly and give you real-time updates."; }, service_type: () => { if (this.extractedData.service_type) { return Excellent choice! ${this.extractedData.service_type} is one of our most popular services. You'll absolutely love the experience we provide.; } if (this.attemptCount[step] > 2) { return "I want to make sure you get exactly what you need! Here's what we offer:\n\nâ€¢ **Airport Transfers** - Professional and punctual\nâ€¢ **Wedding Transport** - Make your day magical\nâ€¢ **Corporate Travel** - Executive business transport\nâ€¢ **Chauffeur Service** - Luxury for any occasion\nâ€¢ **Event Transport** - Red carpet treatment\nâ€¢ **Security Services** - Professional protection\n\nWhich one sounds right for your needs?"; } return "Wonderful! We offer several premium services. Which one interests you?\n\nðŸš— **Chauffeur Service** - Professional transport for any occasion\nâœˆï¸ **Airport Transfers** - Reliable with flight monitoring\nðŸ’’ **Wedding Transport** - Elegant for your special day\nðŸ’¼ **Corporate Transport** - Executive business travel\nðŸŽ­ **Event Transport** - Red carpet service\nðŸ›¡ï¸ **Security Services** - Professional protection\n\nWhat type of transport do you need?"; }, pickup_location: () => { if (this.extractedData.pickup_location) { return "Perfect! I've got your pickup location noted. Our chauffeur will find you easily there."; } if (this.attemptCount[step] > 2) { return "For pickup location, I just need enough detail for our chauffeur to find you - like 'Manchester Airport Terminal 2' or '123 High Street, London' or even 'Hilton Hotel, City Center'. What works for you?"; } const serviceType = this.extractedData.service_type; if (serviceType?.includes('Airport')) { return "Excellent! Are you traveling from your home, hotel, or office to the airport? Just let me know the pickup address."; } else if (serviceType?.includes('Wedding')) { return "How exciting! Where should we collect you for your special day? Your home, hotel, or the venue where you're getting ready?"; } return "Great! Where would you like us to pick you up? Could be your home, office, hotel - wherever is convenient for you."; }, dropoff_location: () => { if (this.extractedData.dropoff_location) { return "Perfect destination! Our chauffeur will get you there in comfort and style."; } if (this.attemptCount[step] > 2) { return "For your destination, just give me enough detail so our chauffeur knows exactly where to take you. What's your destination?"; } return "Excellent! And where are we taking you? What's your destination address or location?"; }, booking_date: () => { if (this.extractedData.booking_date) { return "Perfect! I've noted your travel date. Our team will ensure everything is ready for you."; } if (this.attemptCount[step] > 2) { return "For the date, you can say it however feels natural - like 'December 25th', '25/12/2024', 'next Friday', or even 'tomorrow'. When do you need the transport?"; } return "Great! When do you need this transport? You can tell me the date in any format - like 'December 25th' or '25/12/2024' or even 'next Friday'."; }, booking_time: () => { if (this.extractedData.booking_time) { return "Excellent timing! I've got that noted in your booking."; } if (this.attemptCount[step] > 2) { return "For the time, just let me know what works - like '2:30 PM', '14:30', or even 'early morning' or 'evening'. What time suits you?"; } return "Perfect! What time would you like to be picked up? You can say it any way - like '2:30 PM' or '14:30' or whatever's easiest for you."; }, passenger_count: () => { if (this.extractedData.passenger_count) { const count = this.extractedData.passenger_count; return Got it! ${count} passenger${count > 1 ? 's' : ''}. I'll make sure we have the perfect vehicle for your group.; } if (this.attemptCount[step] > 2) { return "Just need to know how many people will be traveling - this helps me pick the right vehicle size for your comfort!"; } return "Wonderful! How many passengers will be traveling? This helps me suggest the most comfortable vehicle for you."; }, vehicle_preference: () => { if (this.extractedData.vehicle_preference) { return "Perfect choice! That vehicle will be absolutely ideal for your journey."; } return this.getVehicleRecommendation(); }, special_requirements: () => { if (this.extractedData.special_requirements) { if (this.extractedData.special_requirements.toLowerCase().includes('none')) { return "Perfect! No special requirements makes it nice and straightforward."; } return "Excellent! I've noted your special requirements. Our team will make sure everything is arranged perfectly."; } if (this.attemptCount[step] > 2) { return "Special requirements could be anything - child seats, wheelchair access, refreshments, multiple stops, or even just 'nothing special'. What would make your journey perfect?"; } return "Almost done! Do you have any special requirements? Things like child seats, refreshments, specific route preferences, or anything else that would make your journey perfect?\n\nOr just let me know if everything's straightforward!"; }, confirmation: () => this.getConfirmationResponse() }; const responseFunction = responses[step]; return responseFunction ? responseFunction() : "I'm here to help with your VIP transport booking. How can I assist you?"; } private getVehicleRecommendation(): string { const serviceType = this.extractedData.service_type; const passengerCount = this.extractedData.passenger_count || 1; let recommendations = []; if (serviceType?.includes('Wedding')) { recommendations = [ 'Rolls Royce - The ultimate in luxury for your special day', 'Bentley - Sophisticated elegance and style', 'Luxury Sedan - Classic and beautifully refined' ]; } else if (serviceType?.includes('Corporate')) { recommendations = [ 'Executive Sedan - Professional and discreet', 'Luxury SUV - Spacious and prestigious', 'Premium MPV - Perfect for business teams' ]; } else if (serviceType?.includes('Security')) { recommendations = [ 'Armored Vehicle - Maximum protection and security', 'Executive SUV - Secure yet comfortable', 'Security Escort - Multi-vehicle protection' ]; } else { if (passengerCount <= 3) { recommendations = [ 'Executive Sedan - Comfortable and professional', 'Luxury SUV - Spacious and prestigious' ]; } else { recommendations = [ 'Luxury SUV - Spacious for your group', 'Premium MPV - Perfect for larger parties' ]; } } return Based on your ${serviceType?.toLowerCase() || 'transport needs'} and ${passengerCount} passenger${passengerCount > 1 ? 's' : ''}, here are my recommendations:\n\n${recommendations.map(r => â€¢ ${r}).join('\n')}\n\nWhich appeals to you, or would you like me to choose the best option?; } private extractDataFromResponse(userMessage: string, step: string): void { const message = userMessage.trim(); switch (step) { case 'name': // Extract any name-like text const nameMatch = message.match(/(?:i'm|i am|name is|call me)\s+([a-zA-Z\s]+)/i) || message.match(/^([a-zA-Z\s]{2,30})$/); if (nameMatch) { this.extractedData.customer_name = nameMatch[1].trim(); } else if (message.length > 1 && message.length < 50 && !message.toLowerCase().includes('not')) { // Assume single word/phrase responses are names this.extractedData.customer_name = message; } break; case 'email': const emailMatch = message.match(/\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/); if (emailMatch) { this.extractedData.customer_email = emailMatch[0]; } break; case 'phone': // More flexible phone matching const phoneMatch = message.match(/(\+44|0)[\s-]?(\d{4})[\s-]?(\d{3})[\s-]?(\d{3})|(\d{5})[\s-]?(\d{6})/) || message.match(/\b\d{10,15}\b/); if (phoneMatch) { this.extractedData.customer_phone = phoneMatch[0]; } break; case 'service_type': const lowerMessage = message.toLowerCase(); const serviceMap = { 'chauffeur': 'Chauffeur Service', 'airport': 'Airport Transfers', 'wedding': 'Wedding Transport', 'corporate': 'Corporate Transport', 'business': 'Corporate Transport', 'event': 'Event Transport', 'security': 'Security Services', 'transfer': 'Airport Transfers' }; for (const [key, value] of Object.entries(serviceMap)) { if (lowerMessage.includes(key)) { this.extractedData.service_type = value; break; } } break; case 'pickup_location': case 'dropoff_location': if (message.length > 3 && !message.toLowerCase().includes('don\'t know')) { this.extractedData[step] = message; } break; case 'booking_date': // Flexible date parsing if (message.toLowerCase().includes('today')) { this.extractedData.booking_date = 'Today'; } else if (message.toLowerCase().includes('tomorrow')) { this.extractedData.booking_date = 'Tomorrow'; } else if (message.match(/\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}/)) { this.extractedData.booking_date = message; } else if (message.match(/(monday|tuesday|wednesday|thursday|friday|saturday|sunday)/i)) { this.extractedData.booking_date = message; } break; case 'booking_time': const timeMatch = message.match(/\d{1,2}[:\.]?\d{0,2}\s?(am|pm|AM|PM)?/); if (timeMatch) { this.extractedData.booking_time = message; } break; case 'passenger_count': const countMatch = message.match(/\d+/); if (countMatch) { this.extractedData.passenger_count = parseInt(countMatch[0]); } else if (message.toLowerCase().includes('one') || message.toLowerCase().includes('just me')) { this.extractedData.passenger_count = 1; } else if (message.toLowerCase().includes('two')) { this.extractedData.passenger_count = 2; } else if (message.toLowerCase().includes('three')) { this.extractedData.passenger_count = 3; } break; case 'vehicle_preference': if (message.toLowerCase().includes('no preference') || message.toLowerCase().includes('you choose') || message.toLowerCase().includes('surprise me')) { this.extractedData.vehicle_preference = 'No specific preference - please select suitable vehicle'; } else if (message.length > 3) { this.extractedData.vehicle_preference = message; } break; case 'special_requirements': if (message.toLowerCase().includes('none') || message.toLowerCase().includes('no special') || message.toLowerCase().includes('nothing') || message.toLowerCase().includes('no requirements')) { this.extractedData.special_requirements = 'None'; } else if (message.length > 2) { this.extractedData.special_requirements = message; } break; } } private getNextStep(): string { const currentIndex = this.stepOrder.indexOf(this.currentStep); if (currentIndex < this.stepOrder.length - 1) { return this.stepOrder[currentIndex + 1]; } return 'completed'; } private isStepComplete(step: string): boolean { switch (step) { case 'name': return !!this.extractedData.customer_name; case 'email': return !!this.extractedData.customer_email; case 'phone': return !!this.extractedData.customer_phone; case 'service_type': return !!this.extractedData.service_type; case 'pickup_location': return !!this.extractedData.pickup_location; case 'dropoff_location': return !!this.extractedData.dropoff_location; case 'booking_date': return !!this.extractedData.booking_date; case 'booking_time': return !!this.extractedData.booking_time; case 'passenger_count': return !!this.extractedData.passenger_count; case 'vehicle_preference': return !!this.extractedData.vehicle_preference; case 'special_requirements': return !!this.extractedData.special_requirements; default: return true; } } private getConfirmationResponse(): string { return Perfect! Let me confirm everything for you:\n\n${this.getBookingSummary()}\n\nDoes this all look correct? Just say 'yes' to confirm and I'll submit your booking, or let me know if you'd like to change anything!; } private getBookingSummary(): string { return ðŸ“‹ **Your VIP Transport Booking** ðŸ‘¤ **Name:** ${this.extractedData.customer_name} ðŸ“§ **Email:** ${this.extractedData.customer_email} ðŸ“± **Phone:** ${this.extractedData.customer_phone} ðŸš— **Service:** ${this.extractedData.service_type} ðŸ“ **Pickup:** ${this.extractedData.pickup_location} ðŸŽ¯ **Destination:** ${this.extractedData.dropoff_location} ðŸ“… **Date:** ${this.extractedData.booking_date} â° **Time:** ${this.extractedData.booking_time} ðŸ‘¥ **Passengers:** ${this.extractedData.passenger_count} ðŸš™ **Vehicle:** ${this.extractedData.vehicle_preference} ðŸ“ **Requirements:** ${this.extractedData.special_requirements}; } async processMessage(userMessage: string): Promise<{ response: string; bookingReady: boolean; extractedData: BookingData }> { console.log('Processing message:', userMessage, 'Current step:', this.currentStep); const userChatMessage: ChatMessage = { role: 'user', content: userMessage, timestamp: new Date() }; this.conversationHistory.push(userChatMessage); // Reset off-topic count if message is relevant const analysis = this.analyzeUserMessage(userMessage); if (analysis.isRelevant || analysis.containsData) { this.offTopicCount = 0; } // If user is disinterested, end conversation gracefully if (analysis.intent === 'goodbye' && analysis.sentiment === 'negative') { this.userInterestLevel = 'disinterested'; const response = "I completely understand! No pressure at all. If you ever need VIP transport services in the future, I'll be here to help. Have a wonderful day! ðŸ˜Š"; const assistantMessage: ChatMessage = { role: 'assistant', content: response, timestamp: new Date() }; this.conversationHistory.push(assistantMessage); await this.saveConversation(); return { response, bookingReady: false, extractedData: this.extractedData }; } // Extract data from user response (but be more intelligent about it) if (this.currentStep !== 'greeting') { this.extractDataFromResponse(userMessage, this.currentStep); } let response = ''; let bookingReady = false; // Handle confirmation step if (this.currentStep === 'confirmation') { if (userMessage.toLowerCase().match(/\b(yes|yep|yeah|correct|confirm|looks good|perfect|submit|book it|let's do it|go ahead)\b/)) { this.currentStep = 'submission'; bookingReady = true; response = "Excellent! I'm processing your booking request now... ðŸŽ‰"; } else if (userMessage.toLowerCase().match(/\b(no|nope|change|wrong|incorrect|fix|update|modify)\b/)) { response = "Of course! What would you like to change? Just tell me which detail needs updating and I'll fix it right away."; // Don't change step - let them specify what to change } else { // If unclear, ask for clarification response = "I want to make sure everything's perfect! Should I go ahead and submit this booking, or would you like to change something first?"; } } else if (this.currentStep === 'submission') { response = "ðŸŽ‰ Wonderful! Your booking request has been submitted successfully!\n\nHere's what happens next:\nâ€¢ Our team will review your request within 30 minutes\nâ€¢ You'll receive a confirmation call or email\nâ€¢ We'll coordinate all journey details with you\n\nðŸ“ž **For immediate assistance:** 07464 247 007\nðŸ“§ **Email:** bookings@viptransportandsecurity.co.uk\n\nThank you for choosing VIP Transport and Security! Is there anything else I can help you with today?"; } else { // Generate intelligent response response = this.getIntelligentResponse(userMessage); // Check if current step is complete and move to next if (this.isStepComplete(this.currentStep)) { this.currentStep = this.getNextStep(); // If we just completed a step, add the next question if (this.currentStep !== 'completed' && this.currentStep !== 'confirmation') { const nextResponse = this.getStepResponse(this.currentStep, '', analysis); if (response && !response.includes(nextResponse)) { response += \n\nNow, ${nextResponse.toLowerCase()}; } } } } const assistantMessage: ChatMessage = { role: 'assistant', content: response, timestamp: new Date() }; this.conversationHistory.push(assistantMessage); // Save conversation await this.saveConversation(); console.log('Current extracted data:', this.extractedData); console.log('Booking ready:', bookingReady); return { response, bookingReady, extractedData: this.extractedData }; } private async saveConversation() { try { const conversationData = { session_id: this.sessionId, messages: this.conversationHistory.map(msg => ({ role: msg.role, content: msg.content, timestamp: msg.timestamp.toISOString() })), status: this.currentStep === 'submission' ? 'completed' : 'active' }; const { error } = await supabase .from('chat_conversations') .upsert(conversationData, { onConflict: 'session_id' }); if (error) { console.error('Error saving conversation:', error); } else { console.log('Conversation saved successfully'); } } catch (error) { console.error('Error in saveConversation:', error); } } async submitBooking(): Promise<any> { try { console.log('Submitting booking with data:', this.extractedData); // Format date and time properly let formattedDate = null; let formattedTime = null; if (this.extractedData.booking_date) { const dateStr = this.extractedData.booking_date.toLowerCase(); if (dateStr.includes('today')) { const today = new Date(); formattedDate = today.toISOString().split('T')[0]; } else if (dateStr.includes('tomorrow')) { const tomorrow = new Date(); tomorrow.setDate(tomorrow.getDate() + 1); formattedDate = tomorrow.toISOString().split('T')[0]; } else { const dateMatch = this.extractedData.booking_date.match(/(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})/); if (dateMatch) { const [, day, month, year] = dateMatch; const fullYear = year.length === 2 ? 20${year} : year; formattedDate = ${fullYear}-${month.padStart(2, '0')}-${day.padStart(2, '0')}; } } } if (this.extractedData.booking_time) { const timeStr = this.extractedData.booking_time.toLowerCase(); if (timeStr.includes('pm') || timeStr.includes('am')) { const timeMatch = timeStr.match(/(\d{1,2})[:\.]?(\d{0,2})\s?(am|pm)/); if (timeMatch) { let [, hours, minutes = '00', period] = timeMatch; hours = parseInt(hours); if (period === 'pm' && hours !== 12) hours += 12; if (period === 'am' && hours === 12) hours = 0; formattedTime = ${hours.toString().padStart(2, '0')}:${minutes.padStart(2, '0')}:00; } } else { const timeMatch = timeStr.match(/(\d{1,2})[:\.](\d{2})/); if (timeMatch) { formattedTime = ${timeMatch[1].padStart(2, '0')}:${timeMatch[2]}:00; } } } const bookingData = { conversation_id: this.sessionId, customer_name: this.extractedData.customer_name || null, customer_email: this.extractedData.customer_email || null, customer_phone: this.extractedData.customer_phone || null, pickup_location: this.extractedData.pickup_location || null, dropoff_location: this.extractedData.dropoff_location || null, booking_date: formattedDate, booking_time: formattedTime, service_type: this.extractedData.service_type || null, vehicle_preference: this.extractedData.vehicle_preference || null, passenger_count: this.extractedData.passenger_count || 1, special_requirements: this.extractedData.special_requirements || null, extracted_data: this.extractedData, status: 'pending' }; console.log('Formatted booking data:', bookingData); const { data, error } = await supabase .from('ai_bookings') .insert([bookingData]) .select(); if (error) { console.error('Supabase error:', error); throw error; } console.log('Booking saved successfully:', data); // Update conversation with booking ID if (data && data[0]) { await supabase .from('chat_conversations') .update({ booking_id: data[0].id, status: 'completed' }) .eq('session_id', this.sessionId); } return data?.[0]; } catch (error) { console.error('Error submitting booking:', error); throw error; } } getConversationHistory(): ChatMessage[] { return this.conversationHistory; } getExtractedData(): BookingData { return this.extractedData; } resetConversation(): void { this.conversationHistory = []; this.extractedData = {}; this.currentStep = 'greeting'; this.userInterestLevel = 'medium'; this.hasGreeted = false; this.offTopicCount = 0; this.attemptCount = {}; this.stepOrder.forEach(step => { this.attemptCount[step] = 0; }); } }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
